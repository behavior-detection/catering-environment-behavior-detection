// yolo_data_processor.js
const fs = require('fs');
const path = require('path');
const axios = require('axios');

class YoloDataProcessor {
    constructor(config = {}) {
        this.config = {
            batchOutputDir: config.batchOutputDir || './batch_out',
            imagesDir: config.imagesDir || './batch_out/images',
            jsonDir: config.jsonDir || './batch_out/json',
            serverUrl: config.serverUrl || 'http://localhost:3000',
            processInterval: config.processInterval || 10000,
            ...config
        };

        this.processedFiles = new Set();
        this.processedHashes = new Set();
        this.isProcessing = false;
        this.violationStats = {
            totalProcessed: 0,
            totalViolations: 0,
            violationsByType: {},
            violationsByCamera: {}
        };
    }

    start() {
        console.log('ÂêØÂä®YOLOÊï∞ÊçÆÂ§ÑÁêÜÂô®...');
        console.log(`ÁõëÊéßÁõÆÂΩï: ${this.config.jsonDir}`);

        this.ensureDirectories();

        setInterval(() => {
            this.processNewFiles();
        }, this.config.processInterval);

        this.processNewFiles();
    }

    ensureDirectories() {
        [this.config.batchOutputDir, this.config.imagesDir, this.config.jsonDir].forEach(dir => {
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
                console.log(`ÂàõÂª∫ÁõÆÂΩï: ${dir}`);
            }
        });
    }

    async processNewFiles() {
        if (this.isProcessing) return;
        this.isProcessing = true;

        try {
            const jsonFiles = fs.readdirSync(this.config.jsonDir)
                .filter(f => f.endsWith('.json') && !this.processedFiles.has(f));

            if (jsonFiles.length > 0) {
                console.log(`üìÅ ÂèëÁé∞ ${jsonFiles.length} ‰∏™Êñ∞ÁöÑJSONÊñá‰ª∂`);
            }

            for (const jsonFile of jsonFiles) {
                try {
                    await this.processJsonFile(jsonFile);
                    this.processedFiles.add(jsonFile);
                } catch (error) {
                    console.error(`‚ùå Â§ÑÁêÜÊñá‰ª∂Â§±Ë¥• ${jsonFile}:`, error.message);
                }
            }

            if (jsonFiles.length > 0) {
                console.log(`üìä Â§ÑÁêÜÁªüËÆ°: Â∑≤Â§ÑÁêÜ ${this.violationStats.totalProcessed} ‰∏™Êñá‰ª∂ÔºåÊ£ÄÊµãÂà∞ ${this.violationStats.totalViolations} Ê¨°ËøùËßÑ`);
            }

        } catch (error) {
            console.error('‚ùå Êâ´ÊèèÁõÆÂΩïÂ§±Ë¥•:', error.message);
        } finally {
            this.isProcessing = false;
        }
    }

    async processJsonFile(jsonFileName) {
        const jsonPath = path.join(this.config.jsonDir, jsonFileName);

        console.log(`üìù Â§ÑÁêÜÊñá‰ª∂: ${jsonFileName}`);

        // ËØªÂèñÂπ∂Ëß£ÊûêJSON
        let detectionData;
        try {
            const jsonContent = fs.readFileSync(jsonPath, 'utf8');
            detectionData = JSON.parse(jsonContent);
        } catch (error) {
            throw new Error(`Ëß£ÊûêJSONÂ§±Ë¥•: ${error.message}`);
        }

        // Â§ÑÁêÜÊï∞ÊçÆ
        const processedData = this.processDetectionData(detectionData, jsonFileName);

        // ÁîüÊàêÂÜÖÂÆπÂìàÂ∏åÂéªÈáç
        const contentHash = this.generateContentHash(processedData);
        if (this.processedHashes.has(contentHash)) {
            console.log(`‚ö†Ô∏è Ë∑≥ËøáÈáçÂ§çÊï∞ÊçÆ: ${jsonFileName}`);
            return;
        }

        // ‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
        const recordId = await this.saveToDatabase(processedData);
        this.processedHashes.add(contentHash);

        // Êõ¥Êñ∞ÁªüËÆ°
        this.updateStats(processedData);

        console.log(`‚úÖ ÊàêÂäüÂ§ÑÁêÜ: ${jsonFileName} (ËÆ∞ÂΩïID: ${recordId}) - ËøùËßÑ${processedData.total_violations}Ê¨°`);
    }

    processDetectionData(rawData, fileName) {
        // ÊèêÂèñËøùËßÑÊï∞ÊçÆ
        const violations = {};
        let totalViolations = 0;

        if (rawData.violations && typeof rawData.violations === 'object') {
            for (const [type, count] of Object.entries(rawData.violations)) {
                if (typeof count === 'number' && count > 0) {
                    violations[type] = count;
                    totalViolations += count;
                }
            }
        }

        // Â¶ÇÊûúÊ≤°Êúâviolations‰ΩÜÊúâtotal_violationsÔºåÂü∫‰∫éÊëÑÂÉèÂ§¥‰º∞ÁÆó
        if (Object.keys(violations).length === 0 && rawData.total_violations > 0) {
            totalViolations = rawData.total_violations;
            const cameraId = rawData.camera_id || this.extractCameraIdFromFileName(fileName);
            Object.assign(violations, this.estimateViolations(totalViolations, cameraId));
        }

        // Ëß£ÊûêÊó∂Èó¥Êà≥
        const timestamp = this.parseTimestamp(rawData.timestamp);

        return {
            camera_id: rawData.camera_id || this.extractCameraIdFromFileName(fileName),
            detection_timestamp: timestamp,
            violations: violations,
            total_violations: totalViolations,
            source_file: fileName
        };
    }

    estimateViolations(totalViolations, cameraId) {
        const violations = {};

        if (totalViolations <= 0) return violations;

        // Ê†πÊçÆÊëÑÂÉèÂ§¥Êô∫ËÉΩÂàÜÈÖç
        if (cameraId === 'cam_28') {
            violations.mask = Math.ceil(totalViolations * 0.6);
            violations.hat = totalViolations - violations.mask;
        } else if (cameraId === 'cam_11') {
            violations.hat = Math.ceil(totalViolations * 0.7);
            violations.mask = totalViolations - violations.hat;
        } else {
            violations.mask = Math.ceil(totalViolations * 0.5);
            violations.hat = totalViolations - violations.mask;
        }

        // ÁßªÈô§0ÂÄº
        Object.keys(violations).forEach(key => {
            if (violations[key] <= 0) delete violations[key];
        });

        return violations;
    }

    extractCameraIdFromFileName(fileName) {
        const match = fileName.match(/^(D\d+)/);
        if (match) {
            const mapping = { 'D11': 'cam_11', 'D28': 'cam_28', 'D34': 'cam_34' };
            return mapping[match[1]] || match[1];
        }
        return 'unknown';
    }

    parseTimestamp(timestampStr) {
        try {
            if (timestampStr && timestampStr.includes('Âπ¥')) {
                const match = timestampStr.match(/(\d{4})Âπ¥(\d{2})Êúà(\d{2})Êó•.*?(\d{2}):(\d{2}):(\d{2})/);
                if (match) {
                    const [, year, month, day, hour, minute, second] = match;
                    return new Date(`${year}-${month}-${day}T${hour}:${minute}:${second}`);
                }
            }
            return new Date(timestampStr || Date.now());
        } catch (error) {
            return new Date();
        }
    }

    generateContentHash(processedData) {
        const crypto = require('crypto');
        const content = `${processedData.camera_id}_${processedData.detection_timestamp.toISOString()}_${JSON.stringify(processedData.violations)}_${processedData.total_violations}`;
        return crypto.createHash('md5').update(content).digest('hex');
    }

    async saveToDatabase(processedData) {
        try {
            // ÂàõÂª∫Âπ≤ÂáÄÁöÑËøùËßÑÊï∞ÊçÆÂØπË±°
            const violationDataObject = {
                violations: processedData.violations,
                total_violations: processedData.total_violations,
                camera_id: processedData.camera_id,
                source: 'yolo_processor_fixed',
                processed_at: new Date().toISOString(),
                source_file: processedData.source_file
            };

            // JSONÂ∫èÂàóÂåñ
            const violationDataJson = this.createSafeJson(violationDataObject);

            const requestData = {
                camera_id: processedData.camera_id,
                detection_timestamp: processedData.detection_timestamp,
                violation_data: violationDataJson, // ÂèëÈÄÅJSONÂ≠óÁ¨¶‰∏≤
                total_violations: processedData.total_violations
            };

            console.log(`üíæ ‰øùÂ≠òÊï∞ÊçÆ: ${processedData.camera_id} - ${processedData.total_violations}Ê¨°ËøùËßÑ`);

            const response = await axios.post(`${this.config.serverUrl}/api/violations/save`, requestData, {
                headers: { 'Content-Type': 'application/json' },
                timeout: 8000
            });

            if (response.data.success) {
                return response.data.record_id;
            } else {
                throw new Error(response.data.message || '‰øùÂ≠òÂ§±Ë¥•');
            }

        } catch (error) {
            console.error('‚ùå Êï∞ÊçÆÂ∫ì‰øùÂ≠òÂ§±Ë¥•:', error.message);
            throw error;
        }
    }

    createSafeJson(obj) {
        try {
            // Á°Æ‰øùÂØπË±°ÁªìÊûÑÂπ≤ÂáÄ
            const cleanObj = {
                violations: {},
                total_violations: 0,
                camera_id: 'unknown',
                source: 'yolo_processor_fixed',
                processed_at: new Date().toISOString()
            };

            // ÂÆâÂÖ®Â§çÂà∂violations
            if (obj.violations && typeof obj.violations === 'object') {
                for (const [key, value] of Object.entries(obj.violations)) {
                    if (typeof value === 'number' && value >= 0) {
                        cleanObj.violations[key] = value;
                    }
                }
            }

            // ÂÆâÂÖ®Â§çÂà∂ÂÖ∂‰ªñÂ≠óÊÆµ
            if (typeof obj.total_violations === 'number') {
                cleanObj.total_violations = obj.total_violations;
            }
            if (typeof obj.camera_id === 'string') {
                cleanObj.camera_id = obj.camera_id;
            }
            if (typeof obj.source_file === 'string') {
                cleanObj.source_file = obj.source_file;
            }

            // Â∫èÂàóÂåñ
            const jsonString = JSON.stringify(cleanObj);

            // È™åËØÅ
            if (jsonString.includes('[object Object]') || jsonString.includes('undefined')) {
                throw new Error('JSONÂåÖÂê´Êó†ÊïàÂÜÖÂÆπ');
            }

            // ÊµãËØïËß£Êûê
            const testParse = JSON.parse(jsonString);
            if (typeof testParse.violations !== 'object') {
                throw new Error('violationsÂ≠óÊÆµÊó†Êïà');
            }

            return jsonString;

        } catch (error) {
            console.error('‚ùå ÂàõÂª∫ÂÆâÂÖ®JSONÂ§±Ë¥•:', error);
            // ËøîÂõûÊúÄÂü∫Êú¨ÁöÑÁªìÊûÑ
            return JSON.stringify({
                violations: {},
                total_violations: 0,
                camera_id: 'unknown',
                source: 'fallback'
            });
        }
    }

    updateStats(processedData) {
        this.violationStats.totalProcessed++;
        this.violationStats.totalViolations += processedData.total_violations;

        // ÊåâÁ±ªÂûãÁªüËÆ°
        for (const [type, count] of Object.entries(processedData.violations)) {
            this.violationStats.violationsByType[type] =
                (this.violationStats.violationsByType[type] || 0) + count;
        }

        // ÊåâÊëÑÂÉèÂ§¥ÁªüËÆ°
        this.violationStats.violationsByCamera[processedData.camera_id] =
            (this.violationStats.violationsByCamera[processedData.camera_id] || 0) + processedData.total_violations;
    }

    getStats() {
        return {
            ...this.violationStats,
            processedFiles: this.processedFiles.size,
            processedHashes: this.processedHashes.size,
            isProcessing: this.isProcessing,
            lastCheck: new Date().toISOString()
        };
    }

    resetProcessedFiles() {
        this.processedFiles.clear();
        this.processedHashes.clear();
        console.log('Â∑≤ÈáçÁΩÆÂ§ÑÁêÜÂô®ËÆ∞ÂΩï');
    }

    stop() {
        console.log('ÂÅúÊ≠¢YOLOÊï∞ÊçÆÂ§ÑÁêÜÂô®...');
        this.isProcessing = false;
    }
}

module.exports = YoloDataProcessor;